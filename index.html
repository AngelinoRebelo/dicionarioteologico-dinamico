// This is a Netlify serverless function.
// It receives a term from the frontend, queries the Gemini API for a detailed theological analysis,
// and returns the structured data as JSON.

exports.handler = async function(event, context) {
    // --- Security and Method Check ---
    // Only allow POST requests.
    if (event.httpMethod !== 'POST') {
        return {
            statusCode: 405,
            body: JSON.stringify({ error: 'Method Not Allowed' }),
        };
    }

    // --- Input Validation ---
    let termo;
    try {
        const body = JSON.parse(event.body);
        termo = body.termo;
        if (!termo || typeof termo !== 'string' || termo.trim() === '') {
            throw new Error('Termo (term) is required.');
        }
    } catch (error) {
        return {
            statusCode: 400,
            body: JSON.stringify({ error: `Bad Request: ${error.message}` }),
        };
    }

    // --- Gemini API Configuration ---
    // Note: In a real Netlify environment, you should store your API key as an environment variable.
    // For example: process.env.GEMINI_API_KEY
    const apiKey = ""; // Leave this empty, it will be handled by the environment.
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

    // --- Prompt Engineering ---
    // This is the core instruction for the AI. It's designed to request a specific JSON structure
    // that matches what the frontend's `renderResult` function expects.
    const prompt = `
        Análise teológica aprofundada do termo "${termo}".

        Siga estritamente o seguinte formato JSON para a sua resposta. Não inclua markdown (como \`\`\`json) na resposta, apenas o objeto JSON puro.

        {
          "portugues": "Explicação detalhada do significado teológico do termo em português, com 2-3 frases.",
          "hebraico": {
            "termo": "O termo hebraico equivalente, se houver. Se não, use 'N/A'.",
            "strong": "O número da Concordância de Strong para o termo hebraico, se aplicável. Ex: 'H1234'. Se não, use null.",
            "silabico": "A transliteração silábica do termo hebraico. Ex: 'ber-esh-eet'. Se não, use null.",
            "significado_puro": "O significado literal ou da raiz da palavra hebraica. Se não, use null.",
            "significado": "A definição completa da Concordância de Strong para o termo hebraico. Se não houver, explique brevemente por que não se aplica."
          },
          "grego": {
            "termo": "O termo grego equivalente, se houver. Se não, use 'N/A'.",
            "strong": "O número da Concordância de Strong para o termo grego, se aplicável. Ex: 'G1234'. Se não, use null.",
            "significado_puro": "O significado literal ou da raiz da palavra grega. Se não, use null.",
            "significado": "A definição completa da Concordância de Strong para o termo grego. Se não houver, explique brevemente por que não se aplica."
          },
          "latim": {
            "termo": "O termo em latim (da Vulgata), se houver. Se não, use 'N/A'.",
            "significado_puro": "O significado literal ou da raiz da palavra latina. Se não, use null.",
            "significado": "Uma breve definição do termo em latim no contexto teológico. Se não houver, explique brevemente por que não se aplica."
          },
          "comentarios": [
            {
              "texto": "Um comentário ou citação perspicaz sobre o termo por um teólogo da lista fornecida.",
              "autor": "Nome do autor (deve ser um dos seguintes: F. F. Bruce, Craig S. Keener, Ben Witherington III, N. T. Wright)",
              "referencia": "Fonte da citação (livro, sermão, etc.), se conhecida. Se não, use null."
            }
          ],
          "referencias_biblicas": [
            {
              "citacao": "A referência do versículo. Ex: 'João 3:16'",
              "texto": "O texto completo do versículo."
            },
            {
              "citacao": "Outra referência de versículo. Ex: 'Romanos 5:8'",
              "texto": "O texto completo do outro versículo."
            }
          ]
        }

        Se um campo não for aplicável, preencha com 'N/A' para strings, null para outros tipos, ou um array vazio [] para listas, mas mantenha a estrutura JSON intacta.
        Forneça duas referências bíblicas e, se possível, pelo menos um comentário de um dos seguintes autores: F. F. Bruce, Craig S. Keener, Ben Witherington III, ou N. T. Wright. Se encontrar comentários relevantes de mais de um deles, adicione objetos adicionais ao array 'comentarios'.
    `;

    // --- API Request Payload ---
    const payload = {
        contents: [{
            parts: [{ text: prompt }]
        }],
        generationConfig: {
            responseMimeType: "application/json",
        }
    };

    // --- API Call with Error Handling and Retries ---
    try {
        let response;
        let attempts = 0;
        const maxAttempts = 3;
        let delay = 1000; // 1 second initial delay

        // Exponential backoff retry mechanism
        while (attempts < maxAttempts) {
            try {
                response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });

                if (response.ok) {
                    break; // Success, exit loop
                }

                // If response is not ok, but not a server error that warrants a retry
                if (response.status < 500) {
                     const errorData = await response.json();
                     throw new Error(`API Error: ${response.status} - ${errorData.error?.message || 'An unknown client error occurred.'}`);
                }

                // For server errors (5xx), wait and retry
                console.warn(`API call failed with status ${response.status}. Retrying in ${delay / 1000}s...`);

            } catch (networkError) {
                 // Catch fetch-specific errors (e.g., network issues)
                 console.warn(`Network error during API call: ${networkError.message}. Retrying in ${delay / 1000}s...`);
            }

            attempts++;
            if (attempts < maxAttempts) {
                 await new Promise(resolve => setTimeout(resolve, delay));
                 delay *= 2; // Double the delay for the next retry
            } else {
                 throw new Error(`API call failed after ${maxAttempts} attempts.`);
            }
        }

        const result = await response.json();

        // --- Response Handling ---
        // The Gemini API response is nested, so we need to extract the actual content.
        if (!result.candidates || !result.candidates[0] || !result.candidates[0].content || !result.candidates[0].content.parts || !result.candidates[0].content.parts[0].text) {
             throw new Error("Invalid response structure from API.");
        }

        // The model's response is a string containing JSON, so we return it directly.
        // The frontend will parse this.
        return {
            statusCode: 200,
            headers: { 'Content-Type': 'application/json' },
            body: result.candidates[0].content.parts[0].text,
        };

    } catch (error) {
        console.error("Error in Netlify function:", error);
        return {
            statusCode: 500,
            body: JSON.stringify({ error: `Internal Server Error: ${error.message}` }),
        };
    }
};
